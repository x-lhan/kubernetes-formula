{% set version = "v1.7.0" %}
{% set k8s_env = "defaults" %}
{% if grains['k8s_env'] is defined %}
{% set k8s_env = grains['k8s_env'] %}
{% endif %}
{% set master_nodes = salt['mine.get']('kubernetes:' + k8s_env + ':master', 'network.internal_ip', 'pillar') -%}
{% set master_ips = master_nodes.values() -%}
{% set pool_nodes = salt['mine.get']('kubernetes:' + k8s_env + ':pool', 'network.internal_ip', 'pillar') -%}
k8s_env: {{ k8s_env }}

kubernetes:
  master_ips: {{master_ips}}

  # version info
  version: {{ version }}
  kube-apiserver_docker_tag: {{ version }}
  kube-controller-manager_docker_tag: {{ version }}
  kube-scheduler_docker_tag: {{ version }}
  kube-proxy_docker_tag: {{ version }}
  flannel_docker_tag: v0.7.1-amd64
  
  # image info
  kube_docker_registry: "gcr.io/google_containers"
  hyperkube_image: gcr.io/google_containers/hyperkube
  flannel_image: "quay.io/coreos/flannel"
  
  # determine support systemd or not
  {% if grains['oscodename'] in [ 'vivid', 'wily', 'jessie', 'xenial', 'yakkety' ] %}
  is_systemd: True
  systemd_system_path: /lib/systemd/system
  {% elif grains['os_family'] == 'RedHat' %}
  is_systemd: True
  systemd_system_path: /usr/lib/systemd/system
  {% else %}
  is_systemd: False
  {% endif %}
  
  # Recommand set of admission control plugins
  admission_control: "NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds"
  
  # Pod-to-pod network provider. support "cni" and "kubenet", defualt to "cni".
  network_provider: "cni"
  # actual cni provider to use when "network_provider" is "cni". support "canal" and "flannel", defualt to "canal"
  cni_provider: "canal"
  # Service CIDR; when changed please also change "master_extra_sans" and "dns_server" and regenerate cluster certificates
  service_cluster_ip_range: "10.254.0.0/16"
  # Cluster pod CIDR
  cluster_cidr: "10.150.0.0/16"
  # Host network interface that binded, when changed please make sure mine funcation "network.internal_ip" is also changed
  bind_iface: eth0
  flannel_backend_mode: vxlan
  allocate_node_cidrs: true
  
  # If true, allow containers to request privileged mode.
  allow_privileged: true
  
  # Default log level to warning, consider increase to level 2(info) or level 4(debug) for more detail logs
  log_level: "--v=0"
  

  # If true, override node hostname to use saltstack minion_id and make minion_id resolvable using /etc/hosts file on master node.
  # Please note: in AWS even though hostname is override the nodename is discovered using cloud meta-data instead.
  minion_id_as_hostname: false
  master_nodes: {{master_nodes}}
  pool_nodes: {{pool_nodes}}
  
  # kuberentes api_server configurations
  api_server:
    # when put multiply api_server behind load-balancer, please put load-balancer address here 
    ip: {{ master_ips[0] }}
    port: 6443
    # when changed, please regenerate cluster certificates
    fqdn: kubernetes.api
    # If true, api_server will be schedulable like pool node. Default to false
    register_schedulable: false
    # If true, api_server will be able to exec/log like pool node using kubectl. Default to false
    debugging_handlers: false
  
  # certificates sans
  master_extra_sans: "IP:10.254.0.1,DNS:kubernetes,DNS:kubernetes.default,DNS:kubernetes.default.svc,DNS:kubernetes.default.svc.cluster.local"
  certs_files:
    - 'ca.crt'
    - 'server.key'
    - 'server.cert'
    - 'kubecfg.key'
    - 'kubecfg.crt'
  # Authentication
  admin:
    username: admin
  token:
    admin: DFvQ8GJ9JD4fKNfuyEddw3rjnFTkUKsv
    kube_proxy: DFvQ8GelB7afH3wClC9romaMPhquyyEe
    kubelet:  7bN5hJ9JD4fKjnFTkUKsvVNfuyEddw3r
  
  # storage class
  enable_default_storage_class: False
  default_storage_class_zones: ""
  
  # etcd
  keep_host_etcd: False
  
  # dashboard
  enable_cluster_ui: True
  
  # rescheduler
  enable_rescheduler: True
  
  # cluster_autoscaler
  cluster_autoscaler: 
    enabled: False
    params: []
  
  # dns
  enable_cluster_dns: True
  dns_server: 10.254.254.254
  dns_domain: cluster.local
  federations_domain_map: ""
  
  # registry(require cloud provider support and enable_default_storage_class)
  enable_cluster_registry: False
  registry_server: 10.254.50.50
  cluster_registry_disk_size: 1Gi
  cluster_registry_storage_classname: gp2

      